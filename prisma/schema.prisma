generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int       @id @default(autoincrement())
  username       String    @unique
  email          String    @unique
  password       String
  bio            String?
  name           String?
  profilePicture String?
  latitude       Float?
  longitude      Float?
  searchDistance Int       @default(50)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  messagesSent   Message[] @relation("MessagesSent")

  clothes  Clothing[]
  matchesA Match[]    @relation("UserMatchesA")
  matchesB Match[]    @relation("UserMatchesB")

  // Likes sent by this user
  likesSent Like[] @relation("LikesSent")

  blocksInitiated Block[] @relation("Blocker")
  blocksReceived  Block[] @relation("Blocked")

  tradesSent     TradeOffer[] @relation("TradeFromUser")
  tradesReceived TradeOffer[] @relation("TradeToUser")

  // Removed problematic self-relations:
  // blocking  User[]   @relation("Blocking", references: [id])
  // blockedBy User[]   @relation("BlockedBy", references: [id])
}

model Clothing {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  category    String
  size        String?
  condition   String?
  traded      Boolean  @default(false)
  owner       User     @relation(fields: [ownerId], references: [id])
  ownerId     Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  images ClothingImage[]

  matchesA Match[] @relation("ClothingA")
  matchesB Match[] @relation("ClothingB")

  tradeOffersFrom     TradeOffer[] @relation("OfferFrom")
  tradeOffersTo       TradeOffer[] @relation("OfferTo")

  likesReceived Like[] @relation("LikesReceived")
}

model Like {
  id           Int      @id @default(autoincrement())
  fromUser     User     @relation("LikesSent", fields: [fromUserId], references: [id])
  fromUserId   Int
  toClothing   Clothing @relation("LikesReceived", fields: [toClothingId], references: [id])
  toClothingId Int
  createdAt    DateTime @default(now())
}

model ClothingImage {
  id         Int      @id @default(autoincrement())
  url        String
  clothing   Clothing @relation(fields: [clothingId], references: [id], onDelete: Cascade)
  clothingId Int
  createdAt  DateTime @default(now())

  @@index([clothingId])
}

model Match {
  id          Int       @id @default(autoincrement())
  userA       User      @relation("UserMatchesA", fields: [userAId], references: [id])
  userAId     Int
  userB       User      @relation("UserMatchesB", fields: [userBId], references: [id])
  userBId     Int
  clothingA   Clothing? @relation("ClothingA", fields: [clothingAId], references: [id])
  clothingAId Int?
  clothingB   Clothing? @relation("ClothingB", fields: [clothingBId], references: [id])
  clothingBId Int?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  messages Message[]

  tradeOffers   TradeOffer[]

  @@unique([userAId, userBId])
  @@unique([clothingAId, clothingBId])
}

model Message {
  id        Int      @id @default(autoincrement())
  content   String
  sender    User     @relation("MessagesSent", fields: [senderId], references: [id])
  senderId  Int
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchId   Int
  createdAt DateTime @default(now())

  @@index([matchId])
  @@index([senderId])
  @@index([createdAt])
}

model Block {
  id        Int      @id @default(autoincrement())
  blocker   User     @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blockerId Int
  blocked   User     @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)
  blockedId Int
  reason    String?
  createdAt DateTime @default(now())

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

model TradeOffer {
  id             Int      @id @default(autoincrement())
  match          Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchId        Int

  fromUser       User     @relation("TradeFromUser", fields: [fromUserId], references: [id])
  fromUserId     Int

  toUser         User     @relation("TradeToUser", fields: [toUserId], references: [id])
  toUserId       Int

  clothingFrom   Clothing @relation("OfferFrom", fields: [clothingFromId], references: [id])
  clothingFromId Int

  clothingTo     Clothing @relation("OfferTo", fields: [clothingToId], references: [id])
  clothingToId   Int

  status         TradeStatus @default(PENDING)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([matchId, status])
}

enum TradeStatus {
  PENDING
  ACCEPTED
  DECLINED
}